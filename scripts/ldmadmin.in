#!/usr/bin/env python3

###############################################################################
#
#
# Description: This Python script provides a command line interface to LDM
#  programs. It is invoked as an executabe script.
#
#
#   @file:  ldmadmin
# @author:  Mustapha Iles
#
#    Copyright 2021 University Corporation for Atmospheric Research
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Files:
#
#  $LDMHOME/ldmd.pid         file containing process group ID
#  $LDMHOME/.ldmadmin.lck    lock file for operations that modify the state of
#                            the LDM system
#  $LDMHOME/.[0-9a-f]*.info  product-information of the last, successfuly-
#                            received data-product
#
###############################################################################

# Standard Library imports

from 	os 		import system, environ
import 	sys
import 	readline
from 	signal 	import signal, SIGINT
from 	sys 	import exit
from 	time 	import sleep

# configure.ac replaces "@variable@"with actual value:
ldmhome 	= environ.get("LDMHOME", "@LDMHOME@")
ldm_port 	= "@LDM_PORT@"
ldm_version = "@VERSION@"
exec_prefix	= "@EXEC_PREFIX@"

# For testing purposes:
ldmhome 	= "/home/miles/projects/ldm"	# <<---- remove in production setting !!!!!!!!!!!!!!!!!!!!!!!!!!
exec_prefix = ""				# <<---- remove in production setting !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ldm_port 	= "388"				# <<---- remove in production setting !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ldm_version = "6.13.14"			# <<---- remove in production setting !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Set sys.path to locate python modules in $ldmhome/lib
sys.path.append(f"{ldmhome}/execlib")


# Temporarily:
sys.path.append('/home/miles/dev/pydev/lib')

# Local application imports
import parseCLI 		as parseCli
import parseRegistry 	as regHdler
import environHandler	as envHdler
import ldmSubs			as sub
import ldmUtils			as util

EXIT_MESSAGE='\n\tThank you for using ldmadmin...\n\n'

def bye(signal_received, frame):
	# Handle any cleanup here
	exitMessage("")


def exitMessage(msg):
	print(f"\n{msg} \n{EXIT_MESSAGE}")
	exit(0)


class LDMCommandsHandler:
	def __init__(self, cmdsDico):
		self.cmdsDico	= cmdsDico
		self.ldmShortCmdsList	= []
		for cmd, optionList in cmdsDico.items():
			self.ldmShortCmdsList.append(cmd)
	        
	def complete(self,userInput,state):
		results =  [cmd + " " for cmd in self.ldmShortCmdsList if cmd.startswith(userInput)] + [None]
		return results[state]

	def isValidCmd(self, cmd):		
		return cmd in self.ldmShortCmdsList

	def returnCmdCortege(self, cmd):
		return self.cmdsDico[cmd][0]

	def displayRegistryAndEnv(self, regH, envH):
		envH.prettyPrintEnvVars()
		regH.prettyPrintRegistry()


	def cmdDispatcher(self, cmd, reg, env):

		ldmCommandsDict = {
	    	"start": 				"sub.start_ldm(reg, env)",	# checked without params
	    	"stop":					"sub.stop_ldm(reg, env)",	# checked: OK
	        "restart": 				"sub.restart(reg, env)",	# checked without params
	        "mkqueue":				"sub.make_pq(reg, env)",	# checked: OK
	        "delqueue":				"sub.del_pq(reg, env)",		# checked: OK
	        "mksurfqueue":			"sub.make_surf_pq(reg, env)",		# checked: OK
	        "delsurfqueue":			"sub.del_surf_pq(reg, env)",		# checked: OK
	        "newlog":				"sub.newLog(reg, env)",		# checked: OK
	        "scour":				"sub.scour(reg)",
	        "isrunning":			"sub.isRunning(reg, env, pingFlag)", 	# checked: OK
	        "checkinsertion": 		"sub.check_insertion(reg)",	# checked: OK BUT not enough data		
	        "vetqueuesize":			"sub.vetQueueSize(reg, env)", #  checked BUT not enough data
	        "check":				"sub.checkLdm(reg, env)",	# checked: OK
	        "watch":				"sub.watch(reg, env)",		# checked: OK
	        "pqactcheck":			"sub.pqactcheck(reg, env)", # checked: OK
	        "pqactHUP":				"sub.pqactHUP(env)",
	        "queuecheck":			"sub.queueCheck(reg, env)",	# checked: OK        
	        "config":				"sub.ldmConfig(reg, env)",	# checked: OK
	        "log":					"sub.pageLog(reg)",			# checked: OK
	        "tail":					"sub.tailLog(reg)",			# checked: OK
	        "clean":				"sub.clean(reg, env)", 		# checked: OK
	        "checktime":			"sub.checkTime(reg)",		# checked: OK
	        "printmetrics":			"sub.printMetrics(reg, False)",	# checked: OK
	        "addmetrics":			"sub.addMetrics(reg)",		# checked: OK
	        "plotmetrics":			"sub.plotMetrics(reg, env)", 	# checked: OK
	        "newmetrics":			"sub.newMetrics(reg)",			# checked: OK
	        "updategempaktables": 	"sub.updateGempakTables()"	# checked: OK
    	}

		pingFlag = True

		eval(ldmCommandsDict[cmd])



	# cortege not needed here. move its values (begin, end, etc.) to envVar
	def execute(self, cmd, reg, envVar, envt, cli):

		status 				= 0
		pqact_conf_option 	= envVar['pqact_conf_option']
		ldmhome 			= envVar['ldmhome']
		toLockOrNot 		= cli.isLockingRequired(cmd)
		cmdToExecute = f"{cmd} " # {cortege}"
		if toLockOrNot == True:
			if envt.getLock() == -1:
				print(f"Could not get lock for '{cmdToExecute}' to execute properly!")
				status = -1
				return status

			#print(f"\nExecuting in locked mode : \t{cmdToExecute}\n")
			#cmdToExecute = f"{cmdToExecute}, lock=True, pqact_conf_option={pqact_conf_option}"

			self.cmdDispatcher(cmd, reg, envVar)
			envt.releaseLock()

		else:
			#print(f"\nExecuting in NON locked mode : \n\n\t{cmdToExecute}\n")
			#cmdToExecute = f"{cmdToExecute}, lock=False, pqact_conf_option={pqact_conf_option}"
			
			self.cmdDispatcher(cmd, reg, envVar)

		return status


def main():
	signal(SIGINT, bye)
	system('clear')
	debug = True #False

	# Should not be running as root - but permitted:
	util.checkWhoIAm()

	
	regParser 	= regHdler.RegistryParser(ldmhome)
	envt		= envHdler.LDMenvironmentHandler(exec_prefix, ldmhome, ldm_port, ldm_version)

	# Registry dict:
	regDico 	= regParser.getRegistryEntries()


	# tab completion:
	readline.parse_and_bind("tab: complete")
	cliInst 		= parseCli.CLIParser(ldmhome)	
	cmdsDico 		= cliInst.getFullCommandsDict()
		
	LDMcommands 	= LDMCommandsHandler( cmdsDico )	# instance of 'this'
	
	
	#debug = 0
	if debug:
		LDMcommands.displayRegistryAndEnv(regParser, envt)

	readline.set_completer(LDMcommands.complete)



	nbArguments=len(sys.argv)
	if nbArguments == 1 or \
		nbArguments == 2 and (sys.argv[1] == "-h" or sys.argv[1] == "--help"):

# Interactive mode
		cliInst.usage()
		print(f"\n\tInteractive mode (type 'quit' to exit). Not implemented yet.\n")
	

	else:

# Non-interactive mode (CLI mode)
		cmd=sys.argv[1]

		# Ensure that the registry is available because a locked registry will cause
		# this script to hang. (Is this valid for a Python script??)
		if sub.resetRegistry():
		    	exitMessage("Registry unavailable! Bailing out!")

		if not LDMcommands.isValidCmd(cmd):
			print(f"\n\tInvalid ldmadmin command: {cmd}\n")
			sleep(3)
			cliInst.usage()
			exitMessage("")

		# Here, cmd is a valid ldmadmin command:
		if cmd == "usage": 
			cliInst.usage()

		
		# if  nbArguments == 2: # command w/o options
		# 	status 			= LDMcommands.execute(cmd, envt)
		# else:	


		cliDico 	= cliInst.cliParserAddArguments(cmd)
		cliCortege 	= cliInst.buildCLIcortege(cmd, cliDico) # cortege is not needed, the call is.
		#print(f"\n\nCLI dict: {cliDico}\n")
		
		# Copy the cli arguments to envVar to make them available at execution time
		envVar  	= envt.getEnvVarsDict()
		util.copyCliArgsToEnvVariable(envVar, cliDico)

		#print("\n---------------- envVar ----------\n")
		#print(envVar)
		
		LDMcommands.execute(cmd, regDico, envVar, envt, cliInst)

		# last line:
		exitMessage("")

# Interactive mode ###################################################################

	# if None:
	# 	cmd = input('ldmadmin> ')
	# 	while not cmd == "quit":
			
	# 		cmd=cmd.strip()
	# 		if cmd == "usage": 
	# 			cliInst.usage()


	# 		if cmd == "quit":
	# 			exitMessage("")

	# 		if not LDMcommands.isValidCmd(cmd):
	# 			print(f"Invalid ldmadmin command: {cmd}\n")
	# 			cmd = input('ldmadmin> ')
	# 			continue

	# 		# Here, cmd is a valid ldmadmin command:
	# 		print(f"{cmd} ---> {LDMcommands.returnCmdCortege(cmd)}")

	# 		# namespace = cliInst.cliParserAddArguments(cmd)
	# 		# #print(f"\n\tnamespace: {namespace}\n")

	# 		# cliCortege = cliInst.buildCLIcommand(cmd, namespace)
	# 		# status = LDMcommands.execute(cmd, cliCortege, envt)



	# 		# last line:
	# 		cmd = input('ldmadmin> ')


	# exitMessage("")

if __name__ == '__main__':

	main()


